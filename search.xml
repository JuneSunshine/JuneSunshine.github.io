<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pythonic: List Comprehension Limits]]></title>
    <url>%2F2017%2F09%2F27%2FPythonic-List-Comprehension-Limits%2F</url>
    <content type="text"><![CDATA[No More Than Two Expressions In List ComprehensionList comprehension supports multiple loops. For example: 12345matrix = [[1,2,3],[4,5,6],[7,8,9]]flat = [x for row in matrix for x in row]print (flat)&gt;&gt;&gt;[1,2,3,4,5,6,7,8,9] Another example would be creating a two-layer depth new list by inputing list: 1234squared = [[x**2 for x in row] for row in matrix]print(squared)&gt;&gt;&gt;[[1,4,9],[16,25,36],[49,64,81]] If there is another loop in expression, list comprehension will become longer. It will be clearer only if splitting it into multiple lines: 1234my_lists = [[1,2,3],[4,5,6],...]flat = [x for sublist1 in my_lists for sublist2 in sublist1 for x in sublist2] From above we can tell that list comprehension under this condition is not simpler than the common way. Therefore, it is not suggested that using list comprehension with more than two expressions.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: List Comprehension]]></title>
    <url>%2F2017%2F09%2F26%2FPythonic-List-Comprehension%2F</url>
    <content type="text"><![CDATA[Better if List Comprehension else Map and FilterList comprehension is a simple way provided by Python to make another list based on one list. 12345a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]squares = [x**2 for x in a]print(squares)&gt;&gt;&gt;[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Unless it is a function with only one parameter, list comprehension is much clearer than ‘map’. 1squares = map(lambda x: x**2, a) List comprehension will filter out the elements in original list so that the generated list does not conclude corresponding computational results. For example: 1234even_squares = [x**2 for x in a if x % 2 == 0]print (even_squares)&gt;&gt;&gt;[4, 16, 36, 64, 100] Of course, the combination of filter and map functions can do the work too, but the code will be harder to read. 12alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)assert even_squares == list(alt) The last thing to mention is that dict and set also have similar mechanism with list. We can use this while writing algorithms. 12345678club_ranks = &#123;'Chelsea': 1, 'Man United': 2, 'Liverpool': 3&#125;rank_dict = &#123;rank: name for name, rank in club_ranks.items()&#125;club_len_set = &#123;len(name) for name in rank_dict.values()&#125;print (rank_dict)print (club_len_set)&gt;&gt;&gt;&#123;1: 'Chelsea', 2: 'Man United', 3: 'Liverpool'&#125;&#123;7, 10, 9&#125; Key Points List comprehension is clearer than built-in map and filter functions List comprehension can skip inputing some elements in list, it can also be done by map but only if combined with filter Dict and set also support comprehension]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[256. Paint House]]></title>
    <url>%2F2017%2F09%2F26%2F256-Paint-House%2F</url>
    <content type="text"><![CDATA[Problem There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. Note:All costs are positive integers. SolutionThis is a typical dynamic programming problem. 123456789101112131415def minCost(self, costs): size = len(costs) if size == 0: return 0 pre = costs[0][:] now = [0]*3 for i in xrange(size-1): now[0] = min(pre[1], pre[2]) + costs[i+1][0] now[1] = min(pre[0], pre[2]) + costs[i+1][1] now[2] = min(pre[0], pre[1]) + costs[i+1][2] pre[:] = now[:] return min(pre)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2017%2F09%2F19%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Problem Reverse a singly linked list. Solution Iterative12345678910111213class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev Recursive1234567891011121314class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ return self._reverse(head) def _reverse(self, node, prev = None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70. Climbing Stairs]]></title>
    <url>%2F2017%2F09%2F05%2F70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Solution]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To My Love Chen]]></title>
    <url>%2F2017%2F08%2F28%2FTo-My-Love-Chen%2F</url>
    <content type="text"><![CDATA[Dear Chen: Happy Chinese Valentine’s Day!You are always the love of my life and I hope you are happy forever.This is the first Chinese Valentine’s Day after our marriage, I have not prepared a good present for you but this love message. I promise that I will try my best to give my all to you. No matter what happens, I will always be by your side. Your beloved,Yang]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[266. Palindrome Permutation]]></title>
    <url>%2F2017%2F08%2F28%2F266-Palindrome-Permutation%2F</url>
    <content type="text"><![CDATA[Problem Given a string, determine if a permutation of the string could form a palindrome. For example,“code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True. Solution CommonThe most common way to solve this problem will be using stack. If a new letter is found, push it into the stack, then pop it out whenever it appears the second time. OptimizedUsing dictionary will be the best solution. Store each letter as a key and the value is the count of its appearance. It is a little faster in this way because the time complexity of search is O(1). Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Palindrome_Permutation.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Semester Plan]]></title>
    <url>%2F2017%2F08%2F23%2FNew-Semester-Plan%2F</url>
    <content type="text"><![CDATA[Plan Distributed System (subject) Data Management Independent Study (subject) Tensorflow project Seek for internship and Co-op Programming Challenges Practice Blog Construction]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2017%2F08%2F20%2FMerge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. SolutionThe base condition is if list1 or list2 is empty, return the other list. Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Merge_Two_Sorted_Lists.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2F2017%2F08%2F17%2FFirst-Missing-Positive%2F</url>
    <content type="text"><![CDATA[Problem Given an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. SolutionPut Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/First_Missing_Positive.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31 & 46 & 47 & 60. Permutations]]></title>
    <url>%2F2017%2F08%2F16%2FPermutations%2F</url>
    <content type="text"><![CDATA[ProblemThis contains: 31 Next Permutation46 Permutations47 Permutations II60 Permutation Sequence 31. Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 Solution]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. Two Sum]]></title>
    <url>%2F2017%2F08%2F16%2FTwo-Sum%2F</url>
    <content type="text"><![CDATA[Problem Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThis appears to be the first and easiest problem on Leetcode. Most people will use the brute force way to solve this problem. However, it is not time efficient. The best way to solve this is using dictionary which means the time efficiency of checking is O(1). Each time a new number is found, it will be added in the dictionary as value while the key is the difference between this number and target. Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/twoSum.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth From End]]></title>
    <url>%2F2017%2F08%2F15%2FRemove-Nth-From-End%2F</url>
    <content type="text"><![CDATA[Problem Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. Solution:Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Remove_Nth_From_End.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Magic Square]]></title>
    <url>%2F2017%2F08%2F14%2FMagic-Square-Algorithm-Study%2F</url>
    <content type="text"><![CDATA[Philosophy In recreational mathematics, a magic square is a n times n square grid where n is the number of cells on each side filled with distinct positive integers in the range 1,2,…,n^2 such that each cell contains a different integer and the sum of the integers in each row, column and diagonal is equal.The sum is called the magic constant or magic sum of the magic square. A square grid with n cells on each side is said to have order n. FootnotePython code link:https://github.com/JuneSunshine/Magic_Square]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2017%2F08%2F09%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[This is a personal blog created by JuneSunshine. This blog will contain mostly software development skills and knowledge. Most of Leetcode blogs are showing optimal solutions.]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
</search>
