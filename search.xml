<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Machine Learning Algorithm: Decision Tree]]></title>
    <url>%2F2018%2F02%2F28%2FMachine-Learning-Algorithm-Decision-Tree%2F</url>
    <content type="text"><![CDATA[What is Decision TreeDecision Tree is a type of supervised learning algorithm that is mostly used for classification problems. Surprisingly, it works for both categorical and continuous dependent variables. In this algorithm, we split the population into two or more homogeneous sets. This is done based on most significant attributes / independent variables to make as distinct groups as possible. More details about Decision Tree can be found here. In the image above, you can see that population is classified into four different groups based on multiple attributes to identify ‘if they will play or not’. To split the population into different heterogeneous groups, it uses various techniques like Gini, Information Gain, Chi-square, entropy.The best way to understand how decision tree works, is to play Jezzball – a classic game from Microsoft (image below). Essentially, you have a room with moving walls and you need to create walls such that maximum area gets cleared off with out the balls. So, every time you split the room with a wall, you are trying to create 2 different populations with in the same room. Decision trees work in very similar fashion by dividing a population in as different groups as possible. Python Code Example123456789101112# Import Library# Import other necessary libraries like pandas, numpy...from sklearn import tree# Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create tree object model = tree.DecisionTreeClassifier(criterion='gini') # for classification, here you can change the algorithm as gini or entropy (information gain) by default it is gini # model = tree.DecisionTreeRegressor() for regression# Train the model using the training sets and check scoremodel.fit(X, y)model.score(X, y)# Predict Outputpredicted= model.predict(x_test)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Algorithm: Logistic Regression]]></title>
    <url>%2F2018%2F02%2F21%2FMachine-Learning-Algorithm-Logistic-Regression%2F</url>
    <content type="text"><![CDATA[What is Logistic RegressionMost importantly, this is a classification algorithm instead of a regression algorithm. It is used to estimate discrete values (Binary values, yes/no, true/false) based on given set of independent variables. In simple words, it predicts the probability of occurrence of an event by fitting data to a logit function. Hence, it is also known as logit regression. Since, it predicts the probability, its output values between 0 and 1. Again, let us try and understand this through a simple example. Let’s say your friend gives you a puzzle to solve. There are only 2 outcome scenarios – either you solve it or you don’t. Now imagine, that you are being given wide range of puzzles / quizzes in an attempt to understand which subjects you are good at. The outcome to this study would be something like this – if you are given a trignometry based tenth grade problem, you are 70% likely to solve it. On the other hand, if it is grade fifth history question, the probability of getting an answer is only 30%. This is what Logistic Regression provides you. Coming to the math, the log odds of the outcome is modeled as a linear combination of the predictor variables. 123odds= p/ (1-p) = probability of event occurrence / probability of not event occurrenceln(odds) = ln(p/(1-p))logit(p) = ln(p/(1-p)) = b0+b1X1+b2X2+b3X3....+bkXk Above, p is the probability of presence of the characteristic of interest. It chooses parameters that maximize the likelihood of observing the sample values rather than that minimize the sum of squared errors (like in ordinary regression). Python Code Example12345678910111213# Import Libraryfrom sklearn.linear_model import LogisticRegression# Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create logistic regression objectmodel = LogisticRegression()# Train the model using the training sets and check scoremodel.fit(X, y)model.score(X, y)# Equation coefficient and Interceptprint('Coefficient: \n', model.coef_)print('Intercept: \n', model.intercept_)# Predict Outputpredicted= model.predict(x_test)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Algorithm: Linear Regression]]></title>
    <url>%2F2018%2F02%2F15%2FMachine-Learning-Algorithm-Linear-Regression%2F</url>
    <content type="text"><![CDATA[What is Linear RegressionLinear regression is used to estimate real values. Here, we establish relationship between independent and dependent variables by fitting a best line. This best line is known as regression line and represented by a linear equation y = ax + b. The best way to understand linear regression is to relive this experience of childhood. For example, we ask a child to arrange people in his class by increasing order of weight, without asking them their weights. What do you think the child will do? He / she would likely look at the height and build of people and arrange them using a combination of these visible parameters. This is linear regression in real life. The child has actually figured out that height and build would be positively correlated to the weight by a relationship, which looks like the equation above. In this equation: y - Dependent Varaible a - Slope x - Independent Variable b - Intercept These coefficients a and b are derived based on minimizing the sum of squared difference of distance between data points and regression line. Linear Regression is of mainly two types: Simple Linear Regression and Multiple Linear Regression. Simple Linear Regression is characterized by one independent variable. While Multiple Linear Regression is characterized by multiple independent variables. While finding best fit line, you can fit a polynomial or curvilinear regression. And these are known as polynomial or curvilinear regression. Python Code Example123456789101112131415161718# Import Library# Import other necessary libraries like pandas, numpy...from sklearn import linear_model# Load Train and Test datasets# Identify feature and response variable(s) and values must be numeric and numpy arraysx_train=input_variables_values_training_datasetsy_train=target_variables_values_training_datasetsx_test=input_variables_values_test_datasets# Create linear regression objectlinear = linear_model.LinearRegression()# Train the model using the training sets and check scorelinear.fit(x_train, y_train)linear.score(x_train, y_train)# Equation coefficient and Interceptprint('Coefficient: \n', linear.coef_)print('Intercept: \n', linear.intercept_)# Predict Outputpredicted= linear.predict(x_test)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Algorithms Overview]]></title>
    <url>%2F2018%2F02%2F04%2FMachine-Learning-Algorithms-Overview%2F</url>
    <content type="text"><![CDATA[Broad Types of Machine Learning Algorithms1. Supervised Learning (Classification &amp; Regression)Explanation:The most important feature of this learning is that it consists of a target / outcome variable which is to be predicted from a give set of predictors. A function that map inputs to desired outputs can be generated using these variables. The training process continues until the model achieves a desired level of accuracy on the training data. Examples: Regression Decision Tree Random Forest KNN Logistic Regression 2. Unsupervised LearningExplanation:We do not have any target or outcome variable to predict / estimate in this learning. It is usually used for clustering. Examples: Apriori Algorithm K-means 3. Reinforcement LearningExplanation:In this learning, the machine is trained to make specific decisions. It often works like this: the machine is exposed to an environment where it trains itself continually using trial and error. This machines learns from past experience and tries to capture the best possible knowledge to make accurate business decisions. Examples: Markov Decision Process List of Common Machine Learning Algorithms Linear Regression Logistic Regression Decision Tree SVM Naive Bayes K-NN K-Means Random Forest Dimensionality Reduction Algorithms Gradient Boosting Algorithms GBM XGBoost LightGBM CatBoost]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Why I Prefer VueJS]]></title>
    <url>%2F2018%2F01%2F27%2FWhy-I-Prefer-VueJS%2F</url>
    <content type="text"><![CDATA[All contents below are concluded from my own experience. If anything related to Vue.js is not accurate, please leave a comment. Thanks! What is Vue.js? Vue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries. In a sentence, Vue.js can provide effective data binding and flexible components by using simple API. Why use Vue.js?Compared to Angularjs and Reactjs, Vue is famous for its easiness and lightweight. The features are: Lightweight Doubly data binding Everything is component]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Announcement: CV Website Updated]]></title>
    <url>%2F2018%2F01%2F14%2FAnnouncement-CV-Website-Updated%2F</url>
    <content type="text"><![CDATA[CV Website Updated/UpgradedAs it is mentioned in last announcement,lijingyang.me is originally built for CSCI 731 class project showcase, but planned for a long-term CV website. After the end of last semester, I started working on this update. It not only trains my web development skills, but also offers a better place for introducing me and my skills to others. This website uses Bootstrap, Jquery and Ajax. Some functionalities are still in development which might not be working well in current status. However, I think it is good enough to be deployed, and this is why I make this announcement and share it with you. I will keep updating my portfolio and random blogs, but tech related blogs will still be updated on this website. Thanks for reading! Hope we can share a common study experience here! A hungry developer,Jingyang Li]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Announcements</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: Map, Filter and Reduce]]></title>
    <url>%2F2017%2F10%2F30%2FPythonic-Map-Filter-and-Reduce%2F</url>
    <content type="text"><![CDATA[Mapmap applies a function to all the items in an input list in the following blueprint: 1map(function_to_apply, list_of_inputs) Usually this is what we do if we want to pass all the list elements to a function one-by-one and then collect the output: 1234items = [1, 2, 3, 4, 5]squared = []for item in items: squared.append(item**2) map allows us to implement this in a much simpler and nicer way: 12items = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, items)) We can even have a list of functions instead of a list of inputs with map. 1234567891011121314def multiply(x): return (x*x)def add(x): return (x+x)funcs = [multiply, add] for i in range(4): value = list(map(lambda x: x(i), funcs)) print (value) # Output:# [0, 0]# [1, 2]# [4, 4]# [9, 6] Filterfilter creates a list of elements for which a function returns True. Example as follows: 12345num_list = range(-3,3)greater_than_zero = list(filter(lambda x: x &gt; 0, num_list))print(greater_than_zero)# Output: [1, 2] The filter resembles a for loop but it is a builtin function and faster. Note:map &amp; filter can be replaced by list/dict/tuple comprehensions. Reducereduce is a function for performing some computation on a list and returning the result. It applies a rolling computation to sequential pairs of values in a list. For example, if we need to compute the sum of a list of integers. The normal way it might be done is using a for loop: 123456sum = 0alist = [1, 2, 3, 4, 5]for num in alist: sum += num # Output: 15 With using reduce: 12345from functools import reducealist = [1, 2, 3, 4, 5]sum = reduce((lambda x, y: x + y), alist)# Output: 15]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
        <tag>Map</tag>
        <tag>Filter</tag>
        <tag>Reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paper Review: Image-based Localization]]></title>
    <url>%2F2017%2F10%2F25%2FPaper-Review-Image-based-Localization%2F</url>
    <content type="text"><![CDATA[IntroductionIn this paper, authors’ contribution is three-fold: Propose a new CNN+LSTM architecture for camera regression Provide the ﬁrst extensive quantitive comparison of CNN-based and SIFT-based localization methods Introduce a new challenging large indoor sequence MethodThis method uses structure-based localization technique to represent a scene. The most important and distinct part of this method is combining machine learning and deep learning method with localization technique. Exactly speaking, there are two machine learning techniques used: CNN: feature extraction LSTM: structured feature correlation The workﬂow is using the pre-trained GoogleNet as input and followed by a fully connected layer which outputs a 2048 dimensional vector which can be seen as the image to be localized. Then an average pooling layer gathers the information of each feature channel for the entire image. The next layer is to learn the correlation among features. However, the high dimensionality of fully connected layers makes the network prone overfitting to training data. The solution to this is LSTM (Long Short-Term Memory), which has the function of reducing the dimensionality of the feature vector in a structured way. The memory units can filter out the most useful feature correlations for the task of pose estimation. ConclusionThis paper is a typical example of computer vision development trend in recent years, which is the combination of deep learning and computer vision to make significant efforts to large-scale image processing.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Paper Review</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paper Review: Tracking-Learning-Detection]]></title>
    <url>%2F2017%2F10%2F25%2FPaper-Review-Tracking-Learning-Detection%2F</url>
    <content type="text"><![CDATA[IntroductionTracking-Learning-Detection (TLD) is a long-term tracking algorithm focusing on a single object by Zdenek Kalal. TLD algorithm consists of three modules: Tracker, Detector and Learn. Tracker is used to track object movement in continuous frames. It is only efficient when the object is always visible. Tracker estimates the object’s position in current frame based on its known position in last frame to create a movement track which can provide positive samples for learning module. Detector is used to detect the error generated from tracker. It will automatically correct the error when it reaches a certain threshold. Learning iteratively trains classifier based on positive and negative samples generated from tracker and detector to improve detector’s accuracy. Methods Tracker: Median-Flow Algorithm Detector: Cascaded Classiﬁer Learning: P-N Learning TRACKER: Median-Flow algorithm: The author assumes that a good tracking algorithm should have “forward-backward consistency”, which means no matter it tracks in forward of time or backward, the trajectory should be the same. Therefore, he invents an error metric called “F-B Error”: The Euclidean distance between current position at k frame and the forward-backward prediction position at k frame from k+p frame. This tracking algorithm uses Lucas-Kanade tracker. DETECTOR: Cascaded Classiﬁer includes: Path Variance Classifier Compute variance of each patch and label the half with lower values as negative samples Ensemble Classifier (Random Ferns Classifier) Similar to random forest, but each layer of the tree has the same threshold for each half of subtrees. Nearest Neighbor Classifier Compute the similarity of the new sample, label it as positive if the value is beyond 0.6 LEARNING: P-Expert: detect false negative samplesN-Expert: detect false positive samples“Structure” is a concept brought up by author, it has two meanings: The target can only appear at one place at each frame The movement of target should be continuous in adjacent frames Take this figure as an example, the target vehicle is the dark one. In each frame, the black bounding box is positive sample detected by detector, the yellow one is positive sample generated from tracker, and the red star denotes final tracking result in each frame.At frame t, the detector doesn’t find the dark vehicle, but P expert thinks that it is also a positive sample based on result from tracker. By the comparison between these two samples, N expert thinks the dark one is more reliable, so it marks the white vehicle as a negative sample. It is similar in frame t+1. In t+2 frame, P expert generates an incorrect result, but it gets excluded by N expert after comparison. Therefore, the target vehicle can still be tracked. ConclusionThe best part of this algorithm in my opinion is the structure. As we can tell, detector is the supervisor of tracker, because detector needs to correct tracker’s results; While tracker is the supervisor of training detector, because it needs to supervise using the detector’s classification results based on tracker’s results.To conclude, a program, instead of a human being, is used to supervise another program’s training process. This is also why P-N learning is called semi-supervised learning.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Paper Review</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: List Slice]]></title>
    <url>%2F2017%2F10%2F07%2FPythonic-List-Slice%2F</url>
    <content type="text"><![CDATA[FundamentalsThere are three different parts of list slice operation: start, end, stride. For easier understanding, we can imagine a whole list is represented as alist[::]. 12345678910111213alist = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']# assume alist[a:b:c]# a - start# b - end# c - stride# As default, a is 0, b is len(alist) and c is 1 if we don't assign # any of them a number. Therefore, we usually leave the space if we # want default values. As follows:assert alist == alist[::]assert alist[:3] == alist[0:3] assert alist[3:] == alist[3:len(alist)] If we want to start counting from the end, negative values can be used to do the job. 12345678a[:] # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']a[:5] # ['a', 'b', 'c', 'd', 'e']a[:-1] # ['a', 'b', 'c', 'd', 'e', 'f', 'g']a[4:] # ['e', 'f', 'g']a[-3:] # ['f', 'g', 'h']a[2:5] # ['c', 'd', 'e']a[2:-1] # ['c', 'd', 'e', 'f', 'g']a[-3:-1] # ['f', 'g'] Even if number out of index, there won’t be an issue during list slicing. On the contrary, it will throw exception during visiting single element. What need to be paid attention to is that a new list will be created after slicing the original list. It means the system is still maintaining the reference towards each object in original list. Therefore, any modifications and changes made on the new list after list slicing will not affect original list. For example: 12345678910b = a[:4]print ("Before: ", b)b[0] = 'z'print ("After: ", b)print ("Original: ")&gt;&gt;&gt;Before: ['a', 'b', 'c', 'd']After: ['z', 'b', 'c', 'd']Original: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Announcement: New Project Website]]></title>
    <url>%2F2017%2F10%2F04%2FAnnouncement-New-Project-Website%2F</url>
    <content type="text"><![CDATA[A New Website Builtlijingyang.me was recently built for project showcase of CSCI 731 class. It is planned to be used for showing all the projects I have done so far in the future, but currently there is only one project on the website. I will also post my bio and social links on it. You can contact me in any ways you like if you are interested at my works. Websites’ Current Functionstofuser.com:Personal Blog, main functions are: Publishing tech related interesting topics, especially coding stuff Publishing some rambles Give a place to have discussions with someone who has same interests with me lijingyang.me:Project Site, main functions are: Projects Proposal Projects Demo]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Announcements</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: Unnecessary Else]]></title>
    <url>%2F2017%2F10%2F04%2FPythonic-Unnecessary-Else%2F</url>
    <content type="text"><![CDATA[Unique Python ElsePython provides a function which is not supported in most of primary languages: To use else statement right behind the loop. 123456789for i in range(3): print ("Loop %s" % i)else: print ("Else what?!")&gt;&gt;&gt;Loop 0Loop 1Loop 2Else what?! You might think this is interesting.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: Use Enumerate() Instead of Range()]]></title>
    <url>%2F2017%2F10%2F03%2FPythonic-Use-Enumerate-Instead-of-Range%2F</url>
    <content type="text"><![CDATA[Try enumerate() moreWhen iterating through integers, the built-in range function is useful: 12for i in range(10): print (i) For strings, we can directly iterate through the list: 123club_list = ['Chelsea', 'Liverpool', 'Barcelona', 'Juventus']for club in club_list: print ("%s is the best!" % club) Sometimes we want to know the index of current element in list while iterating. For example, print the ordered list of football clubs: 123for i in range(len(club_list)): club = club_list[i] print ("%d: %s" % (i+1, club)) However, this method seems a little redundant and also hard to understand. In this situation, Python provides a built-in function: enumerate(). It is a simpler and more elegant way to deal with this. 1234567for i, club in enumerate(club_list): print ("%d: %s" % (i+1, club))&gt;&gt;&gt;1: Chelsea2: Liverpool3: Barcelona4: Juventus We can even assign the starting value of counting, which will make the code even simpler: 12for i, club in enumerate(cub_list, 1): print ("%d: %s" % (i, club)) Key Points: enumerate() offers a simple way of retrieving each element’s index during iteration Try to use enumerate() to replace range() if index is needed We can use a second parameter in enumerate() to assign the starting value of index (0 as default)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: Use of Zip Function]]></title>
    <url>%2F2017%2F10%2F03%2FPythonic-Use-of-Zip-Function%2F</url>
    <content type="text"><![CDATA[This needs more time to be doneUnder Construction…]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: List Comprehension Limits]]></title>
    <url>%2F2017%2F09%2F27%2FPythonic-List-Comprehension-Limits%2F</url>
    <content type="text"><![CDATA[No More Than Two Expressions In List ComprehensionList comprehension supports multiple loops. For example: 12345matrix = [[1,2,3],[4,5,6],[7,8,9]]flat = [x for row in matrix for x in row]print (flat)&gt;&gt;&gt;[1,2,3,4,5,6,7,8,9] Another example would be creating a two-layer depth new list by inputing list: 1234squared = [[x**2 for x in row] for row in matrix]print(squared)&gt;&gt;&gt;[[1,4,9],[16,25,36],[49,64,81]] If there is another loop in expression, list comprehension will become longer. It will be clearer only if splitting it into multiple lines: 1234my_lists = [[1,2,3],[4,5,6],...]flat = [x for sublist1 in my_lists for sublist2 in sublist1 for x in sublist2] From above we can tell that list comprehension under this condition is not simpler than the common way. Therefore, it is not suggested that using list comprehension with more than two expressions.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonic: List Comprehension]]></title>
    <url>%2F2017%2F09%2F26%2FPythonic-List-Comprehension%2F</url>
    <content type="text"><![CDATA[Better if List Comprehension else Map and FilterList comprehension is a simple way provided by Python to make another list based on one list. 12345a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]squares = [x**2 for x in a]print(squares)&gt;&gt;&gt;[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Unless it is a function with only one parameter, list comprehension is much clearer than ‘map’. 1squares = map(lambda x: x**2, a) List comprehension will filter out the elements in original list so that the generated list does not conclude corresponding computational results. For example: 1234even_squares = [x**2 for x in a if x % 2 == 0]print (even_squares)&gt;&gt;&gt;[4, 16, 36, 64, 100] Of course, the combination of filter and map functions can do the work too, but the code will be harder to read. 12alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)assert even_squares == list(alt) The last thing to mention is that dict and set also have similar mechanism with list. We can use this while writing algorithms. 12345678club_ranks = &#123;'Chelsea': 1, 'Man United': 2, 'Liverpool': 3&#125;rank_dict = &#123;rank: name for name, rank in club_ranks.items()&#125;club_len_set = &#123;len(name) for name in rank_dict.values()&#125;print (rank_dict)print (club_len_set)&gt;&gt;&gt;&#123;1: 'Chelsea', 2: 'Man United', 3: 'Liverpool'&#125;&#123;7, 10, 9&#125; Key Points List comprehension is clearer than built-in map and filter functions List comprehension can skip inputing some elements in list, it can also be done by map but only if combined with filter Dict and set also support comprehension]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Pythonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[256. Paint House]]></title>
    <url>%2F2017%2F09%2F26%2F256-Paint-House%2F</url>
    <content type="text"><![CDATA[Problem There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. Note:All costs are positive integers. SolutionThis is a typical dynamic programming problem. 123456789101112131415def minCost(self, costs): size = len(costs) if size == 0: return 0 pre = costs[0][:] now = [0]*3 for i in range(size-1): now[0] = min(pre[1], pre[2]) + costs[i+1][0] now[1] = min(pre[0], pre[2]) + costs[i+1][1] now[2] = min(pre[0], pre[1]) + costs[i+1][2] pre[:] = now[:] return min(pre)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2017%2F09%2F19%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Problem Reverse a singly linked list. Solution Iterative12345678910111213class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev Recursive1234567891011121314class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ return self._reverse(head) def _reverse(self, node, prev = None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70. Climbing Stairs]]></title>
    <url>%2F2017%2F09%2F05%2F70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Solution]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To My Love Chen]]></title>
    <url>%2F2017%2F08%2F28%2FTo-My-Love-Chen%2F</url>
    <content type="text"><![CDATA[Dear Chen: Happy Chinese Valentine’s Day!You are always the love of my life and I hope you are happy forever.This is the first Chinese Valentine’s Day after our marriage, I have not prepared a good present for you but this love message. I promise that I will try my best to give my all to you. No matter what happens, I will always be by your side. Your beloved,Yang]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[266. Palindrome Permutation]]></title>
    <url>%2F2017%2F08%2F28%2F266-Palindrome-Permutation%2F</url>
    <content type="text"><![CDATA[Problem Given a string, determine if a permutation of the string could form a palindrome. For example,“code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True. Solution CommonThe most common way to solve this problem will be using stack. If a new letter is found, push it into the stack, then pop it out whenever it appears the second time. OptimizedUsing dictionary will be the best solution. Store each letter as a key and the value is the count of its appearance. It is a little faster in this way because the time complexity of search is O(1). Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Palindrome_Permutation.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Semester Plan]]></title>
    <url>%2F2017%2F08%2F23%2FNew-Semester-Plan%2F</url>
    <content type="text"><![CDATA[Plan Distributed System (subject) Data Management Independent Study (subject) Tensorflow project Seek for internship and Co-op Programming Challenges Practice Blog Construction]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2017%2F08%2F20%2FMerge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. SolutionThe base condition is if list1 or list2 is empty, return the other list. Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Merge_Two_Sorted_Lists.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2F2017%2F08%2F17%2FFirst-Missing-Positive%2F</url>
    <content type="text"><![CDATA[Problem Given an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. SolutionPut Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/First_Missing_Positive.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31 & 46 & 47 & 60. Permutations]]></title>
    <url>%2F2017%2F08%2F16%2FPermutations%2F</url>
    <content type="text"><![CDATA[ProblemThis contains: 31 Next Permutation46 Permutations47 Permutations II60 Permutation Sequence 31. Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 Solution]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. Two Sum]]></title>
    <url>%2F2017%2F08%2F16%2FTwo-Sum%2F</url>
    <content type="text"><![CDATA[Problem Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThis appears to be the first and easiest problem on Leetcode. Most people will use the brute force way to solve this problem. However, it is not time efficient. The best way to solve this is using dictionary which means the time efficiency of checking is O(1). Each time a new number is found, it will be added in the dictionary as value while the key is the difference between this number and target. Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/twoSum.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth From End]]></title>
    <url>%2F2017%2F08%2F15%2FRemove-Nth-From-End%2F</url>
    <content type="text"><![CDATA[Problem Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. Solution:Python code link:https://github.com/JuneSunshine/Optimized_Leetcode_Solution/blob/master/Remove_Nth_From_End.py]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Magic Square]]></title>
    <url>%2F2017%2F08%2F14%2FMagic-Square-Algorithm-Study%2F</url>
    <content type="text"><![CDATA[Philosophy In recreational mathematics, a magic square is a n times n square grid where n is the number of cells on each side filled with distinct positive integers in the range 1,2,…,n^2 such that each cell contains a different integer and the sum of the integers in each row, column and diagonal is equal.The sum is called the magic constant or magic sum of the magic square. A square grid with n cells on each side is said to have order n. MethodsThere are three different methods applied to solve this puzzle.First of all, all situations can be divided into three categories: Odd by Odd Mezirac method : Start with filling the middle slot of first row | 8 | 1 | 6 || — | — | — || 3 | 5 | 7 || 4 | 9 | 2 | Python code link:https://github.com/JuneSunshine/Magic_Square]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2017%2F08%2F09%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[This is a personal blog created by JuneSunshine. This blog will contain mostly software development skills and knowledge. Most of Leetcode blogs are showing optimal solutions.]]></content>
      <categories>
        <category>Message</category>
      </categories>
      <tags>
        <tag>Ramble</tag>
      </tags>
  </entry>
</search>
